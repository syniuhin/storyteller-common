{
  "name": "Storyteller",
  "tagline": "Отчёт по курсовой работе.",
  "body": "## Вступление\r\n\r\nДля курсовой работы я решил сделать небольшой сервис вокруг статистической модели для генерирования абзаца стилизованного текста по изображению [neural-storyteller](https://github.com/ryankiros/neural-storyteller). Проект состоит из 2 частей: серверной на фреймворке Flask и клиентской на Android.\r\n\r\nВ клиенте основной функционал - это загрузка своих фото, редактирование и сохранение полученных описаний. Так же существует список уже готовых описаний, который кешируется в локальную базу данных.\r\n\r\nТак же я добавил гостевую / демо сессию для того, чтобы пользователи могли попробовать приложение без регистрации.\r\n\r\nДля работы с сетью в клиенте я использовал 3 библиотеки – [Retrofit](https://square.github.io/retrofit/) для удобной работы с API, [RxAndroid](https://github.com/ReactiveX/RxAndroid) ([Reactive eXtensions](http://reactivex.io/) для Android, расширения для удобного асинхронного, реактивного программирования) и [Picasso](https://square.github.io/picasso/) для работы с изображениями.\r\n\r\nПлан\r\n* [Шаблоны сервера](#head_server):\r\n    * [Strategy](#head_strategy)\r\n    * [Chain of Responsibility + Builder](#head_corb)\r\n* [Шаблоны клиента](#head_client):\r\n    * [Template method](#head_template)\r\n    * [Factory Method](#head_factory)\r\n    * [Proxy + Bridge + Adapter](#head_pba)\r\n* [Неявные шаблоны клиента](#head_implicit)\r\n\r\n## <a name=\"head_server\"></a>Шаблоны сервера\r\n\r\n### <a name=\"head_strategy\"></a>Strategy\r\n\r\nВ серверной части для авторизации использует Basic HTTP Authentication. Так как впоследствии я хотел бы добавить аутентификацию через учётные записи Google, где используются OpenID, то я использовал Strategy для текущей и планирую использовать для последующих стратегий аутентификации.\r\n\r\n`auth.util`:\r\n```py\r\nclass AuthUser(Enum):\r\n  auth = 1\r\n  demo = 2\r\n  unknown = 3\r\n\r\nauth.auth_strategies:\r\nclass AuthenticationStrategy(object):\r\n  def check(self, request_data):\r\n    raise NotImplementedError('AuthStrategy is an abstraction!')\r\n\r\n  def get_user_id(self, request_data):\r\n    raise NotImplementedError('AuthStrategy is an abstraction!')\r\n\r\n\r\nclass HttpBasicAuthenticationStrategy(AuthenticationStrategy):\r\n  def check(self, request_data):\r\n    # May be confusing here, but usernames themselves are not unique and emails\r\n    # are.\r\n    if request_data.username == 'foo@example.com' \\\r\n        and request_data.password == 'bar':\r\n      return AuthUser.demo\r\n    potential_user = User.query.filter_by(email=request_data.username).first()\r\n    if potential_user is not None and \\\r\n        potential_user.check_password(request_data.password):\r\n      return AuthUser.auth\r\n    return AuthUser.unknown\r\n\r\n  def get_user_id(self, request_data):\r\n    potential_user = User.query.filter_by(email=request_data.username).first()\r\n    if potential_user is not None:\r\n      return potential_user.id\r\n    return ValueError('There\\'s no such user!')\r\n```\r\n\r\nПример использования:\r\n```py\r\n  def check_auth(self, request):\r\n    if not request.authorization:\r\n      return False\r\n    auth_user = self.auth_strategy.check(request.authorization)\r\n    if auth_user is AuthUser.unknown or auth_user is AuthUser.demo:\r\n      return False\r\n    return True\r\n```\r\n\r\nНемного другим образом я использовал стратегию для авторизации, где для каждой сущности и демо сессии создал отдельные стратегии авторизации, которые работают с конкретной сущностью и `user_id`:\r\n\r\n`auth.auth_strategies`:\r\n```py\r\nclass AuthorizationStrategy(object):\r\n  def check(self, user_id):\r\n    raise NotImplementedError('AuthStrategy is an abstraction!')\r\n\r\n\r\nclass FileAuthorizationStrategy(AuthorizationStrategy):\r\n  def __init__(self, file_id):\r\n    self.file_id = file_id\r\n\r\n  def check(self, user_id):\r\n    # Checks if particular file belongs to a user_id.\r\n    return UploadedFile.query.filter_by(id=self.file_id,\r\n                                        user_id=user_id).first() is not None\r\n\r\n\r\nclass DemoFileAuthorizationStrategy(FileAuthorizationStrategy):\r\n  def check(self, user_id):\r\n    return user_id == -1\r\n\r\n\r\nclass StoryAuthorizationStrategy(AuthorizationStrategy):\r\n  def __init__(self, story_id):\r\n    self.story_id = story_id\r\n\r\n  def check(self, user_id):\r\n    # Checks if particular story belongs to a user_id.\r\n    return Story.query.filter_by(id=self.story_id,\r\n                                 user_id=user_id).first() is not None\r\n```\r\nПример использования:\r\n```py\r\n  def execute(self, fn, **kwargs):\r\n    user_id = kwargs.get('user_id')\r\n    if not self.authorization_strategy.check(user_id):\r\n      abort(401)\r\n    return self.successor.execute(fn, **kwargs)\r\n```\r\n\r\n### <a name=\"head_corb\"></a>Chain of Responsibility + Builder\r\nДля обработки запроса я посчитал уместным использовать Chain of Responsibility, так как некоторые запросы можно просто обработать, некоторые нужно только аутентифицировать, некоторые нужно дополнительно авторизовывать. Так же, впоследствии, я бы хотел использовать разные обработчики для разных видов статистических моделей.\r\n\r\n`auth_handlers.py`:\r\n```py\r\nclass Handler(object):\r\n  \"\"\"\r\n  Abstraction over Chain of Responsibility element (handler).\r\n  We're passing function as a parameter `fn`\r\n  \"\"\"\r\n  def execute(self, fn, **kwargs):\r\n    raise NotImplementedError()\r\n\r\n\r\nclass FinalHandler(Handler):\r\n  \"\"\"\r\n  Simple handler that just executes passed functions.\r\n  \"\"\"\r\n  def execute(self, fn, **kwargs):\r\n    return fn(**kwargs)\r\n\r\n\r\nclass PredecessorHandler(Handler):\r\n  \"\"\"\r\n  Abstract handler that is not in the end of a chain.\r\n  \"\"\"\r\n  def __init__(self, successor):\r\n    self.successor = successor\r\n\r\n  def execute(self, fn, **kwargs):\r\n    raise NotImplementedError()\r\n\r\n\r\nclass AuthenticationHandler(PredecessorHandler):\r\n  def __init__(self, successor, authentication_strategy):\r\n    super(AuthenticationHandler, self).__init__(successor)\r\n    self.auth_strategy = authentication_strategy\r\n\r\n  def check_auth(self, request):\r\n    if not request.authorization:\r\n      return False\r\n    auth_user = self.auth_strategy.check(request.authorization)\r\n    if auth_user is AuthUser.unknown or auth_user is AuthUser.demo:\r\n      return False\r\n    return True\r\n\r\n  def execute(self, fn, **kwargs):\r\n    request = kwargs.get('bound_request')\r\n    if not self.check_auth(request):\r\n      abort(401)\r\n    return self.successor.execute(fn, **kwargs)\r\n\r\n\r\nclass AuthenticationDemoHandler(AuthenticationHandler):\r\n  def __init__(self, successor, authentication_strategy):\r\n    super(AuthenticationDemoHandler, self).__init__(successor,\r\n                                                    authentication_strategy)\r\n\r\n  def check_auth(self, request):\r\n    if not request.authorization:\r\n      return False\r\n    auth_user = self.auth_strategy.check(request.authorization)\r\n    if auth_user is AuthUser.unknown or auth_user is AuthUser.auth:\r\n      return False\r\n    return True\r\n\r\n\r\nclass AuthorizationHandler(PredecessorHandler):\r\n  def __init__(self, successor, authorization_strategy):\r\n    super(AuthorizationHandler, self).__init__(successor)\r\n    self.authorization_strategy = authorization_strategy\r\n\r\n  def execute(self, fn, **kwargs):\r\n    user_id = kwargs.get('user_id')\r\n    if not self.authorization_strategy.check(user_id):\r\n      abort(401)\r\n    return self.successor.execute(fn, **kwargs)\r\n```\r\nК тому же, я посчитал, что раз мы имеем такой удобный интерфейс для обработки наших запросов, то нужно создать удобный интерфейс для создания этих обработчиков. Так как я достаточно неопытный человек в Python и на Java написал побольше кода, то решил реализовать Builder:\r\n```py\r\nclass HandlerBuilder(object):\r\n  \"\"\"\r\n  Builder class to make creation of handlers easier.\r\n  Initializes with FinalHandler by default.\r\n  \"\"\"\r\n  def __init__(self):\r\n    self.handler = FinalHandler()\r\n\r\n  def add_handler(self, predecessor, **kwargs):\r\n    self.handler = predecessor(successor=self.handler, **kwargs)\r\n    return self\r\n\r\n  def build(self):\r\n    return self.handler\r\n```\r\n--- \r\n## <a name=\"head_client\"></a>Шаблоны клиента\r\n### <a name=\"head_template\"></a>Template Method\r\nДля разных подклассов Activity я решил использовать Template Method, потому что последовательность определения разных View, установка им поведения, инициализация сервиса для запросов к серверу у них одинаковая, разнятся лишь конкретные объекты – поля Activity.\r\n```java\r\nabstract public class BaseActivity extends AppCompatActivity {\r\n  ...\r\n  abstract protected void findViews();\r\n\r\n  abstract protected void setupViews();\r\n\r\n  abstract protected void initService();\r\n  ...\r\n}\r\n```\r\n```java\r\npublic class MainActivity extends BaseActivity implements\r\n    LoaderManager.LoaderCallbacks<Cursor>,\r\n    SinglePictureAdapter.StoryItemHolder.ClickCallback {\r\n\r\n  private Toolbar mToolbar;\r\n  private FloatingActionButton mFab;\r\n\r\n  private SwipeRefreshLayout mSwipeRefreshView;\r\n  private RecyclerView mRecyclerView;\r\n  private SinglePictureAdapter mAdapter;\r\n  private LinearLayoutManager mLayoutManager;\r\n\r\n  private StoryService mStoryService = null;\r\n\r\n  @Override\r\n  protected void onCreate(Bundle savedInstanceState) {\r\n    super.onCreate(savedInstanceState);\r\n    setContentView(R.layout.activity_main);\r\n\t...\r\n    findViews();\r\n    setupViews();\r\n    initService();\r\n\t...\r\n  }\r\n\r\n  @Override\r\n  protected void onResume() {\r\n    super.onResume();\r\n    loadStories();\r\n  }\r\n\r\n  protected void findViews() {\r\n    mToolbar = (Toolbar) findViewById(R.id.toolbar);\r\n    mFab = (FloatingActionButton) findViewById(R.id.fab);\r\n    mRecyclerView = (RecyclerView) findViewById(R.id.main_recyclerview);\r\n    mSwipeRefreshView = (SwipeRefreshLayout) findViewById(R.id.main_swipenrefresh);\r\n  }\r\n\r\n  protected void setupViews() {\r\n    setSupportActionBar(mToolbar);\r\n\r\n    mFab.setOnClickListener(new View.OnClickListener() {\r\n      @Override\r\n      public void onClick(View view) {\r\n        startUploadingActivity();\r\n      }\r\n    });\r\n\r\n    mRecyclerView.setHasFixedSize(true);\r\n\r\n    mLayoutManager = new LinearLayoutManager(this);\r\n    mLayoutManager.setReverseLayout(true);\r\n    mLayoutManager.setStackFromEnd(true);\r\n\r\n    mRecyclerView.setLayoutManager(mLayoutManager);\r\n\r\n    mAdapter = new SinglePictureAdapter(\r\n        null, getApplicationContext(), this);\r\n    mRecyclerView.setAdapter(mAdapter);\r\n\r\n    mSwipeRefreshView.setOnRefreshListener(\r\n        new SwipeRefreshLayout.OnRefreshListener() {\r\n          @Override\r\n          public void onRefresh() {\r\n            loadStories();\r\n          }\r\n        });\r\n\r\n    getLoaderManager().initLoader(0, null, this);\r\n  }\r\n\r\n  protected void initService() {\r\n    mStoryService = new StoryServiceProxyBridge(\r\n        new BasicAuthServiceCreator().createInitializer(this)\r\n                                     .create(StoryService.class),\r\n        this, mRecyclerView);\r\n    compositeSubscription = new CompositeSubscription();\r\n  }\r\n  ...\r\n}\r\n```\r\n\r\n### <a name=\"head_factory\"></a>Factory Method\r\nДля разных типов запросов к серверу нам нужны разные типы объектов: наличие аутентификации, её виды, разные временные ограничения для запросов. Для создания этих объектов, ввиду их небольшого разнообразия, я решил применть Factory Method.\r\n\r\nИерархия `ServiceCreator`:\r\n```java\r\nabstract public class ServiceCreator {\r\n  public static final String API_BASE_URL = BASE_IP + \"/storyteller/\";\r\n\r\n  protected Retrofit.Builder retrofitBuilder =\r\n      new Retrofit.Builder()\r\n          .addCallAdapterFactory(RxJavaCallAdapterFactory.create())\r\n          .addConverterFactory(GsonConverterFactory.create())\r\n          .baseUrl(API_BASE_URL);\r\n\r\n  abstract public Retrofit createInitializer(Context context);\r\n}\r\n\r\npublic class SimpleServiceCreator extends ServiceCreator {\r\n  @Override\r\n  public Retrofit createInitializer(Context context) {\r\n    OkHttpClient client = new SimpleClientCreator().createClient(context);\r\n    return retrofitBuilder.client(client).build();\r\n  }\r\n}\r\n\r\npublic class BasicAuthServiceCreator extends ServiceCreator {\r\n  @Override\r\n  public Retrofit createInitializer(Context context) {\r\n    OkHttpClient client = new BasicAuthClientCreator().createClient(context);\r\n    return retrofitBuilder.client(client).build();\r\n  }\r\n}\r\n```\r\nИерархия `ClientCreator`:\r\n```java\r\nabstract public class ClientCreator {\r\n  protected OkHttpClient.Builder httpClientBuilder =\r\n      new OkHttpClient.Builder()\r\n          .connectTimeout(300, TimeUnit.SECONDS)\r\n          .readTimeout(300, TimeUnit.SECONDS);\r\n\r\n  abstract public OkHttpClient createClient(Context context);\r\n}\r\n\r\npublic class SimpleClientCreator extends ClientCreator {\r\n  @Override\r\n  public OkHttpClient createClient(Context context) {\r\n    httpClientBuilder\r\n        .addInterceptor(new HttpLoggingInterceptor()\r\n                            .setLevel(HttpLoggingInterceptor.Level.BODY));\r\n    return httpClientBuilder.build();\r\n  }\r\n}\r\n\r\npublic class BasicAuthClientCreator extends ClientCreator {\r\n  /**\r\n   * @param context: Context to create Picasso.Builder and OkHttpClient.\r\n   * @return Picasso builder for authenticated image loading.\r\n   */\r\n  public static Picasso.Builder createPicassoBuilder(Context context) {\r\n    return new Picasso.Builder(context).downloader(\r\n        new OkHttp3Downloader(\r\n            new BasicAuthClientCreator().createClient(context)));\r\n  }\r\n\r\n  public OkHttpClient createClient(Context context) {\r\n    httpClientBuilder\r\n        .addInterceptor(new HttpLoggingInterceptor()\r\n                            .setLevel(HttpLoggingInterceptor.Level.BASIC));\r\n\r\n    // Get authentication header.\r\n    final String basic = \"Basic \" +\r\n        context.getSharedPreferences(BaseActivity.PREFS_KEY,\r\n                                     Context.MODE_PRIVATE)\r\n               .getString(\"basicAuthHeader\", \"\");\r\n\r\n    httpClientBuilder.addInterceptor(new Interceptor() {\r\n      @Override\r\n      public Response intercept(Interceptor.Chain chain) throws IOException {\r\n        Request original = chain.request();\r\n\r\n        Request.Builder requestBuilder =\r\n            original.newBuilder()\r\n                    .header(\"Authorization\", basic)\r\n                    .header(\"Accept\", \"application/json\")\r\n                    .method(original.method(), original.body());\r\n\r\n        Request request = requestBuilder.build();\r\n        return chain.proceed(request);\r\n      }\r\n    });\r\n\r\n    return httpClientBuilder.build();\r\n  }\r\n}\r\n```\r\n\r\n### <a name=\"head_pba\"></a>Proxy + Bridge + Adapter\r\nВо время работы с сервером могут возникнуть разнообразные проблемы, некоторые из них – отсутствие интернета на клиенте или отсутствие данных для аутентификации. Для того, чтобы облегчить понимание этих проблем и уменьшить бесполезное взаимодействие с сервером я использовал шаблон Proxy. Так как у нас могут быть разные имплементации сервиса запросов, то я решил использовать Bridge для взаимной подмены этих реализаций. В свою очередь, так как Retrofit написана при помощи рефлексии и не позволяет объединять сервисы запросов в иерархии наследования, я написал простенький Adapter, который помогает мне приводить разные сервисы к единому интерфейсу.\r\n\r\nBridge + Proxy в `StoryServiceProxyBridge`:\r\n```java\r\npublic class StoryServiceProxyBridge implements StoryService {\r\n  private StoryService mImpl = null;\r\n  private Context mContext;\r\n  private final SharedPreferences mSp;\r\n  private View mParentView;\r\n\r\n  public StoryServiceProxyBridge(StoryService impl, Context context,\r\n                                 View parentView) {\r\n    mImpl = impl;\r\n    mContext = context;\r\n    mSp = mContext.getSharedPreferences(BaseActivity.PREFS_KEY,\r\n                                        Context.MODE_PRIVATE);\r\n    mParentView = parentView;\r\n  }\r\n\r\n  /**\r\n   * Substitutes implementation of a real StoryService.\r\n   * \r\n   * @param impl: Real StoryService object.\r\n   */\r\n  public void setImplementation(StoryService impl) {\r\n    mImpl = impl;\r\n  }\r\n\r\n  @Override\r\n  public Observable<Response<BasicResponse>> uploadImage(\r\n      @Part MultipartBody.Part file) {\r\n    // Doesn't require authentication\r\n    if (!checkInternetConnection())\r\n      return null;\r\n    return mImpl.uploadImage(file);\r\n  }\r\n\r\n  @Override\r\n  public Observable<Response<Story>> generateStory(long imageId) {\r\n    if (!checkInternetConnection())\r\n      return null;\r\n    if (!checkCredentialsAvailability() && !checkIfCredentialsFake())\r\n      return null;\r\n    return mImpl.generateStory(imageId);\r\n  }\r\n\r\n  @Override\r\n  public Observable<Response<Story>> createStory(@Path(\"image_id\") long imageId,\r\n                                                 @Body Story story) {\r\n    if (!checkInternetConnection())\r\n      return null;\r\n    if (!checkCredentialsAvailability()) {\r\n      if (checkIfCredentialsFake())\r\n        Snackbar.make(mParentView, \"Available only for registered users\",\r\n                      Snackbar.LENGTH_LONG).show();\r\n      return null;\r\n    }\r\n    return mImpl.createStory(imageId, story);\r\n  }\r\n\r\n  @Override\r\n  public Observable<Response<Story.Multiple>> getStoryList() {\r\n    if (!checkInternetConnection())\r\n      return null;\r\n    if (!checkCredentialsAvailability())\r\n      return null;\r\n    return mImpl.getStoryList();\r\n  }\r\n\r\n  @Override\r\n  public Observable<Response<Story.Multiple>> getStoryListSince(\r\n      @Path(\"unix_timestamp\") long timestamp) {\r\n    if (!checkInternetConnection())\r\n      return null;\r\n    if (!checkCredentialsAvailability())\r\n      return null;\r\n    return mImpl.getStoryListSince(timestamp);\r\n  }\r\n\r\n  @Override\r\n  public Observable<Response<Story.Multiple>> getStoryListAfter(\r\n      @Path(\"after_id\") long afterId) {\r\n    if (!checkInternetConnection())\r\n      return null;\r\n    if (!checkCredentialsAvailability())\r\n      return null;\r\n    return mImpl.getStoryListAfter(afterId);\r\n  }\r\n\r\n  private boolean checkInternetConnection() {\r\n    ConnectivityManager cm = (ConnectivityManager) mContext.getSystemService(\r\n        Context.CONNECTIVITY_SERVICE);\r\n    NetworkInfo netInfo = cm.getActiveNetworkInfo();\r\n    if (netInfo != null && netInfo.isConnectedOrConnecting())\r\n      return true;\r\n    Snackbar.make(mParentView, \"Internet connection error\",\r\n                  Snackbar.LENGTH_LONG).show();\r\n    return false;\r\n  }\r\n\r\n  private boolean checkCredentialsAvailability() {\r\n    return !TextUtils.isEmpty(\r\n        mSp.getString(\"basicAuthHeader\", \"\")) && !checkIfCredentialsFake();\r\n  }\r\n\r\n  private boolean checkIfCredentialsFake() {\r\n    return BaseActivity.isDemoRunning(mSp);\r\n  }\r\n}\r\n```\r\n\r\nAdapter для `DemoAccessService`\r\n```java\r\npublic class StoryServiceDemoAdapter implements StoryService {\r\n\r\n  private DemoAccessService mAdaptee;\r\n\r\n  public StoryServiceDemoAdapter(final DemoAccessService adaptee) {\r\n    mAdaptee = adaptee;\r\n  }\r\n\r\n  @Override\r\n  public Observable<Response<BasicResponse>> uploadImage(\r\n      @Part MultipartBody.Part file) {\r\n    return mAdaptee.uploadImage(file);\r\n  }\r\n\r\n  @Override\r\n  public Observable<Response<Story>> generateStory(long imageId) {\r\n    return mAdaptee.generateStory(imageId);\r\n  }\r\n\r\n  @Override\r\n  public Observable<Response<Story>> createStory(@Path(\"image_id\") long imageId,\r\n                                                 @Body Story story) {\r\n    throw new IllegalStateException(\"Not supported in demo!\");\r\n  }\r\n\r\n  @Override\r\n  public Observable<Response<Story.Multiple>> getStoryList() {\r\n    throw new IllegalStateException(\"Not supported in demo!\");\r\n  }\r\n\r\n  @Override\r\n  public Observable<Response<Story.Multiple>> getStoryListSince(\r\n      @Path(\"unix_timestamp\") long timestamp) {\r\n    throw new IllegalStateException(\"Not supported in demo!\");\r\n  }\r\n\r\n  @Override\r\n  public Observable<Response<Story.Multiple>> getStoryListAfter(\r\n      @Path(\"after_id\") long afterId) {\r\n    throw new IllegalStateException(\"Not supported in demo!\");\r\n  }\r\n}\r\n```\r\n\r\nПример использования в `MainActivity`:\r\n```java\r\n  ...\r\n  protected void initService() {\r\n    mStoryService = new StoryServiceProxyBridge(\r\n        new BasicAuthServiceCreator().createInitializer(this)\r\n                                     .create(StoryService.class),\r\n        this, mRecyclerView);\r\n    ...\r\n  }\r\n  ...\r\n```\r\n\r\n## <a name=\"head_implicit\"></a>Неявные шаблоны клиента\r\nХотя я их только использовал, а не проектировал, стоит сказать, что в Retrofit используются Proxy из Java Reflection API, однако они не решают моей задачи и являются очень общими, скорее для более удобного интерфейса объектов библиотеки.\r\n\r\nТак же, всё в RxJava та и вообще всё реактивное программирование построено на шаблоне Observer, который очень активно использовал для работы с сетью в приложении.\r\n\r\nТак же, использовались стандартные и неотъемлимые для разработки под Android шаблоны: ViewHolder (утилизации списка View), ContentProvider (абстрагирования доступа к данным и предоставления доступа к данным своего приложения другим).\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}